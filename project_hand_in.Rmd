---
title: "Final Project For Statistical Learning II"
author: "Ivan Padezhki"
date: "April 20, 2022"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax
for authoring HTML, PDF, and MS Word documents. For more details on
using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that
includes both content as well as the output of any embedded R code
chunks within the document. You can embed an R code chunk like this:

## Including Plots

Note that the `echo = FALSE` parameter was added to the code chunk to
prevent printing of the R code that generated the plot.

# Libraries

```{r, echo=FALSE}
library(tidyverse)
library(ggplot2)
library(corrplot)
library(Hmisc)
library(corrplot)
library(RColorBrewer)
```

# 1. Input of data

## 1.1. Dataset Breast Cancer

<https://www.kaggle.com/code/leemun1/predicting-breast-cancer-logistic-regression/data>,
first accessed 30/05/2022

```{r}
ds <- read.csv("data/diabetes_dataset__2019.csv")
names(ds)
```

```{r}
ds[1:5,]
```

```{r}
summary(ds)
# X is a logical variable that contains only missing values - remove it
```

Get values for categorical variables

```{r}
ncol(ds)
for(i in 1:ncol(ds)) {       # for-loop over columns
  print(cat(names(ds)[i], unique(ds[,i])))
}
```

Fix different values for the blood pressure level variable to have them
equal

```{r}
ds$BPLevel[ds$BPLevel == 'High'] <- 'high'
ds$BPLevel[ds$BPLevel == 'Low'] <- 'low'
ds$BPLevel[ds$BPLevel == 'normal '] <- 'normal'
unique(ds['BPLevel'])
```

```{r}
#cast binary variables to dummies (0/1)
#Gender: Male=1, Female=0
ds_fin <- ds
ds_fin$Gender <- ifelse(ds$Gender == 'Male', 1, 0)

#Diabetes: Yes=1, No=0
ds_fin$Family_Diabetes <- ifelse(ds$Family_Diabetes == 'yes', 1, 0)

#HighBP: Yes=1, No=0
ds_fin$highBP <- ifelse(ds$highBP == 'yes', 1, 0)

#Smoking: Yes=1, No=0

ds_fin$Smoking <- ifelse(ds$Smoking == 'yes', 1, 0)

#Alcohol: Yes=1, No=0

ds_fin$Alcohol <- ifelse(ds$Alcohol == 'yes', 1, 0)

#RegularMedicine: Yes=1, No=0

ds_fin$RegularMedicine <- ifelse(ds$RegularMedicine == 'yes', 1, 0)

#UriationFreq: quite often=1, not much=0 

ds_fin$UriationFreq <- ifelse(ds$UriationFreq == 'quite often', 1, 0)

# Convert remaining categorical columns to factors with suffix _f
# 0 corresponding to lowest factor, 3 to highest

#Age
vec <- as.factor(ds$Age)
f <- factor(vec, levels =  c('less than 40','40-49','50-59','60 or older'))
n <- as.numeric(f)
nn <- n - 1
ds_fin$Age <- nn

#Physically Active

vec <- as.factor(ds$PhysicallyActive)
f <- factor(vec, levels =  c('none','less than half an hr','more than half an hr','one hr or more'))
n <- as.numeric(f)
nn <- n - 1
ds_fin$PhysicallyActive <- nn

#JunkFood
vec <- as.factor(ds$JunkFood)
f <- factor(vec, levels =  c('occasionally','often','very often','always'))
n <- as.numeric(f)
nn <- n - 1
ds_fin$JunkFood <- nn

#Stress

vec <- as.factor(ds$Stress)
f <- factor(vec, levels =  c('not at all','sometimes','very often','always'))
n <- as.numeric(f)
nn <- n - 1
ds_fin$Stress <- nn
```

```{r}
#NUMERIC VARIABLES EDA 

#BMI - continuous 

unique(ds['BMI'])

#Sleep (hours) - continuous

unique(ds['Sleep'])

#SoundSleep (hours) - continuous

unique(ds['SoundSleep'])

#Pregancies (n. of pregnancies) - continuous (0-4)

unique(ds['Pregancies'])

#Pdiabetes - DUMMY (1=had pregnancy diabetes, 0=didn't)

#Fixing the variable Pdiabetes 

unique(ds['Pdiabetes'])

ds_fin$Pdiabetes[ds$Pdiabetes == 'yes'] <- 1
ds_fin$Pdiabetes[ds$Pdiabetes == 'no'] <- 0
ds_fin$Pdiabetes[ds$Pdiabetes == ''] <- NA
ds_fin$Pdiabetes[ds$Pdiabetes == ' no'] <- 0
unique(ds_fin['Pdiabetes'])
```

```{r}
unique(ds['Diabetic'])

ds_fin$Diabetic[ds$Diabetic == 'yes'] <- 1
ds_fin$Diabetic[ds$Diabetic == 'no'] <- 0
ds_fin$Diabetic[ds$Diabetic == ' no'] <- 0
ds_fin$Diabetic[ds$Diabetic == ''] <- NA
unique(ds_fin['Diabetic'])
```

```{r}
#Check that all columns have either numeric data type or factor 

class(ds_fin$BMI)

class(ds_fin$Sleep)

class(ds_fin$SoundSleep)

class(ds_fin$Pregancies)

class(ds_fin$Pdiabetes) #character 

#cast to numeric 

ds_fin$Pdiabetes = as.numeric(ds_fin$Pdiabetes)
class(ds_fin$Pdiabetes)

class(ds_fin$Diabetic) #character 

ds_fin$Diabetic = as.numeric(ds_fin$Diabetic)
class(ds_fin$Diabetic)

class(ds_fin$Age)

class(ds_fin$Gender)

class(ds_fin$Family_Diabetes)

class(ds_fin$highBP)

class(ds_fin$Smoking)

class(ds_fin$Alcohol)

class(ds_fin$RegularMedicine)

class(ds_fin$UriationFreq)

class(ds_fin$PhysicallyActive)

class(ds_fin$JunkFood)

class(ds_fin$Stress)

class(ds_fin$BPLevel)
```

```{r}
summary(ds_fin)
```

Density plots for continuous variables - we don't have continuous variables

```{r}

```
```{r}

```


Balanced output variable?

# 2. Overall cleaning

## 2.1. Identifying Missing Values

Check for any missing values after removing the X column

```{r}
sum(is.na(ds_fin)==TRUE)
```

# 3. Data Exploration

figure out what relevant questions there are in the data Inspect data
and its features what data types are there (numerical, categorical,
ordinal) - they require different treatments

```{r}
#Is BMI connected to diabetes? --> YES 

diab_BMI = ds_fin$BMI[which(ds_fin$Diabetic==1)]
nodiab_BMI = ds_fin$BMI[which(ds_fin$Diabetic==0)]

boxplot(diab_BMI,nodiab_BMI, main = "BMI of diabetic and non-diabetic subjects",ylab = "BMI",names = c("diabetic", "not diabetic"))

diab_BMI = ds_fin$BMI[which(ds_fin$Alcohol==1)]
nodiab_BMI = ds_fin$BMI[which(ds_fin$Alcohol==0)]

boxplot(diab_BMI,nodiab_BMI, main = "BMI of alcohol and non-alcohol subjects",ylab = "BMI",names = c("Alcohol", "No Alcohol"))

diab_BMI = ds_fin$BMI[which(ds_fin$Gender==1)]
nodiab_BMI = ds_fin$BMI[which(ds_fin$Gender==0)]

boxplot(diab_BMI,nodiab_BMI, main = "BMI of Male and Female subjects",ylab = "BMI",names = c("Male", "Female"))


```

## 3.1. Descriptive statistics

visualizations: identify patterns and trends in the data organize and
tidy the data

```{r}
# check correlation between variables
df_cor <- ds_fin %>% mutate_if(is.character, as.factor)
df_cor <- df_cor %>% mutate_if(is.factor, as.numeric)
#run a correlation and drop the insignificant ones
corr <- cor(df_cor, use = "pairwise.complete.obs")
#prepare to drop duplicates    
corr[lower.tri(corr,diag=TRUE)] <- NA 
# print the corr matrix
# print(corr)
```

plot the corr matrix

```{r}
#plot correlations visually
corrplot(corr, is.corr=FALSE, tl.col="black", na.label=" ")
```

```{r}
library(ggcorrplot)
model.matrix(~0+., data=ds_fin) %>% 
  cor(use="pairwise.complete.obs") %>% 
  ggcorrplot(show.diag = F, type="lower", lab=TRUE, lab_size=2)
```

Check if there are some very high correlations

```{r}
w <- which(corr>0.9 & row(corr)<col(corr), arr.ind = TRUE)
# reconstruct names from positions
high_cor <- matrix(colnames(corr)[w],ncol=2)
high_cor
```

Check out some specific correlations

```{r}
cor(ds_fin$Sleep, ds_fin$SoundSleep)
cor(ds_fin$Pregancies, ds_fin$Pdiabetes, use = "pairwise.complete.obs")
```

```{r}
boxplot(BMI~Diabetic, data = ds_fin)
```
```{r}
non_diabetic_tot <- which(ds_fin$Diabetic==0)
#length(non_diabetic_tot) #685 non-diabetic subjects 

diabetic_tot <- which(ds_fin$Diabetic==1)
#length(diabetic_tot) #266 diabetic subjects 

gender_df <- data.frame(table(ds_fin$Diabetic,ds_fin$Gender))
names(gender_df) <- c("Diabetic","Gender","Count")

ggplot(data=gender_df, aes(x=Diabetic, y=Count, fill=Gender, label = Count)) + geom_bar(stat="identity") + geom_text(size = 3, position = position_stack(vjust = 0.5))

```



```{r}
# Is urination frequency connected with diabetes?

urinate_df <- data.frame(table(ds_fin$Diabetic,ds_fin$UriationFreq))
names(urinate_df) <- c("Diabetic","Urination_frequency","Count")

ggplot(data=urinate_df, aes(x=Diabetic, y=Count, fill=Urination_frequency, label = Count)) + geom_bar(stat="identity") + geom_text(size = 3, position = position_stack(vjust = 0.5))
```

End up with a data in a standardized format across all data

# 4. Model data

Use regression and predictions for forecasting future values Or use
classification to identify groups

Reduce dimensionality of the data set - not all our values are
essentials to predicting the model

Select relevant features that contribute to the prediction of results or
apply shrinkage regressions

```{r}
log_reg <- glm(Diabetic ~., data = ds_fin, family = binomial)
summary(log_reg)
```

# 5. Interpret data

How do we present our analysis: basically answer the questions we set in
the beginning using our results - technical details are necessary but
make them accessible - tell a story
